<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>uav-mobility-app.tests.entities.test_Network API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>uav-mobility-app.tests.entities.test_Network</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import unittest
from pathlib import Path
import json
from uav_mobility_app.network_envs.entities.NetworkLink import NetworkLink
from uav_mobility_app.network_envs.entities.NetworkDevice import NetworkDevice
from uav_mobility_app.network_envs.enums.NetworkDeviceType import NetworkDeviceType
from uav_mobility_app.network_envs.entities.NetworkNode import NetworkNode
from uav_mobility_app.network_envs.enums.NetworkNodeType import NetworkNodeType
from uav_mobility_app.network_envs.entities.Network import Network
from uav_mobility_app.network_envs.entities.Network import ExtendedNetworkLink
from uav_mobility_app.network_envs.utils.NetworkJSONParser import parse_json

class test_Network(unittest.TestCase):


    def test_initialization(self):
        &#34;&#34;&#34;Checks that the initialization of a Network is consistent.
        &#34;&#34;&#34;
        input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
        input_data: dict = json.load(open(input_path))
        n_network_nodes: int = len(input_data[&#34;network_nodes&#34;])
        n_gws = len(list(filter(
            lambda network_node: network_node[&#34;node_type&#34;] == &#34;GW&#34;,
            input_data[&#34;network_nodes&#34;])))
        n_sws = len(list(filter(
            lambda network_node: network_node[&#34;node_type&#34;] == &#34;SW&#34;,
            input_data[&#34;network_nodes&#34;])))
        n_aps = len(list(filter(
            lambda network_node: network_node[&#34;node_type&#34;] == &#34;AP&#34;,
            input_data[&#34;network_nodes&#34;])))
        n_network_devices: int = len(input_data[&#34;network_devices&#34;])
        n_network_links: int = len(input_data[&#34;network_links&#34;])
        net = Network(input_path)
        self.assertEqual(len(net.nodes),
                         n_network_devices + n_network_nodes)
        self.assertEqual(len(net.gateways), n_gws)
        self.assertEqual(len(net.switches), n_sws)
        self.assertEqual(len(net.access_points), n_aps)
        self.assertEqual(len(net.edges),
                         n_network_links)

    def test_network_nodes(self):
        &#34;&#34;&#34;Test that the network nodes are consistent w.r.t. the input
        data.
        &#34;&#34;&#34;
        input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
        input_data = parse_json(input_path)
        expected_nodes: list[NetworkNode] = input_data[&#34;network_nodes&#34;]
        net = Network(input_path)
        zipped_nodes = zip(net.network_nodes, expected_nodes)
        for (n1, n2) in zipped_nodes:
            self.assertEqual(n1.id, n2.id)
            self.assertEqual(n1.name, n2.name)
            self.assertEqual(n1.node_type, n2.node_type)
            self.assertEqual(n1.position, n2.position)

    def test_gateways(self):
        &#34;&#34;&#34;Test that the NetworkNodes of type NetworkNodeType.GW are
        consistent w.r.t. the input data.
        &#34;&#34;&#34;
        input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
        input_data: list[NetworkNode] = parse_json(input_path)[&#34;network_nodes&#34;]
        expected_gateways: list[NetworkNode] = list(filter(
            lambda network_node: network_node.node_type == &#34;GW&#34;,
            input_data))
        net = Network(input_path)
        zipped_gateways = zip(net.gateways, expected_gateways)
        for (g1, g2) in zipped_gateways:
            self.assertEqual(g1.id, g2.id)
            self.assertEqual(g1.name, g2.name)
            self.assertEqual(g1.node_type, g2.node_type)
            self.assertEqual(g1.position, g2.position)

    def test_switches(self):
        &#34;&#34;&#34;Test that the NetworkNodes of type NetworkNodeType.SW are
        consistent w.r.t. the input data.
        &#34;&#34;&#34;
        input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
        input_data: list[NetworkNode] = parse_json(input_path)[&#34;network_nodes&#34;]
        expected_switches: list[NetworkNode] = list(filter(
            lambda network_node: network_node.node_type == &#34;SW&#34;,
            input_data))
        net = Network(input_path)
        zipped_switches = zip(net.switches, expected_switches)
        for (s1, s2) in zipped_switches:
            self.assertEqual(s1.id, s2.id)
            self.assertEqual(s1.name, s2.name)
            self.assertEqual(s1.node_type, s2.node_type)
            self.assertEqual(s1.position, s2.position)

    def test_access_points(self):
        &#34;&#34;&#34;Test that the NetworkNodes of type NetworkNodeType.AP are
        consistent w.r.t. the input data.
        &#34;&#34;&#34;
        input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
        input_data: list[NetworkNode] = parse_json(input_path)[&#34;network_nodes&#34;]
        expected_access_points: list[NetworkNode] = list(filter(
            lambda network_node: network_node.node_type == &#34;AP&#34;,
            input_data))
        net = Network(input_path)
        zipped_access_points = zip(net.switches, expected_access_points)
        for (a1, a2) in zipped_access_points:
            self.assertEqual(a1.id, a2.id)
            self.assertEqual(a1.name, a2.name)
            self.assertEqual(a1.node_type, a2.node_type)
            self.assertEqual(a1.position, a2.position)

    def test_network_devices(self):
        &#34;&#34;&#34;Test that the networkDevices are consistent w.r.t. the input
        data.
        &#34;&#34;&#34;
        input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
        input_data = parse_json(input_path)
        expected_devices : list[NetworkDevice] = input_data[&#34;network_devices&#34;]
        net = Network(input_path)
        zipped_devices = zip(net.network_devices, expected_devices)
        for (d1, d2) in zipped_devices:
            self.assertEqual(d1.id, d2.id)
            self.assertEqual(d1.name, d2.name)
            self.assertEqual(d1.device_type, d2.device_type)
            self.assertEqual(d1.throughput_req, d2.throughput_req)
            self.assertEqual(d1.delay_req, d2.delay_req)
            self.assertEqual(d1.position, d2.position)
            self.assertEqual(d1.is_active, d2.is_active)

    def test_uavs(self):
        &#34;&#34;&#34;Test that the NetworkDevices of type NetworkDeviceType.UAV
        are consistent w.r.t. the input data.
        &#34;&#34;&#34;
        input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
        input_data: list[NetworkDevice] = \
            parse_json(input_path)[&#34;network_devices&#34;]
        expected_uavs: list[NetworkDevice] = list(filter(
            lambda network_device: network_device.device_type == &#34;UAV&#34;,
            input_data))
        net = Network(input_path)
        zipped_uavs = zip(net.uavs, expected_uavs)
        for (u1, u2) in zipped_uavs:
            self.assertEqual(u1.id, u2.id)
            self.assertEqual(u1.name, u2.name)
            self.assertEqual(u1.device_type, u2.device_type)
            self.assertEqual(u1.throughput_req, u2.throughput_req)
            self.assertEqual(u1.delay_req, u2.delay_req)
            self.assertEqual(u1.position, u2.position)
            self.assertEqual(u1.is_active, u2.is_active)

    def test_cams(self):
        &#34;&#34;&#34;Test that the NetworkDevices of type NetworkDeviceType.CAM
        are consistent w.r.t. the input data.
        &#34;&#34;&#34;
        input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
        input_data: list[NetworkDevice] = \
            parse_json(input_path)[&#34;network_devices&#34;]
        expected_cams: list[NetworkDevice] = list(filter(
            lambda network_device: network_device.device_type == &#34;CAM&#34;,
            input_data))
        net = Network(input_path)
        zipped_cams = zip(net.cams, expected_cams)
        for (c1, c2) in zipped_cams:
            self.assertEqual(c1.id, c2.id)
            self.assertEqual(c1.name, c2.name)
            self.assertEqual(c1.device_type, c2.device_type)
            self.assertEqual(c1.throughput_req, c2.throughput_req)
            self.assertEqual(c1.delay_req, c2.delay_req)
            self.assertEqual(c1.position, c2.position)
            self.assertEqual(c1.is_active, c2.is_active)

    def test_network_links(self):
        &#34;&#34;&#34;Test that the NetworkLinks are consistent w.r.t. the input
        data.
        &#34;&#34;&#34;
        input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
        input_data = parse_json(input_path)
        expected_links = input_data[&#34;network_links&#34;]
        expected_links: list[NetworkLink] = [l[2] for l in expected_links]
        net = Network(input_path)
        zipped_links = zip(net.network_links, expected_links)
        for (l1, l2) in zipped_links:
            self.assertEqual(l1.id, l2.id)
            self.assertEqual(l1.name, l2.name)
            self.assertEqual(l1.max_throughput, l2.max_throughput)
            self.assertEqual(l1.available_throughput, l2.available_throughput)
            self.assertEqual(l1.routed_flows, l2.routed_flows)
            self.assertEqual(l1.delay, l2.delay)

    def test_shortest_path_to_gw(self):
        &#34;&#34;&#34;Test that the expected shortest paths from the testing
        scenario are returned in different situations.
        &#34;&#34;&#34;
        net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))

        uav0: NetworkDevice = None
        for uav in net.uavs:
            if (uav.name == &#34;uav_00&#34;):
                uav0 = uav
                break
        gateway: NetworkNode = None
        for gw in net.gateways:
            if (gw.name == &#34;gateway&#34;):
                gateway = gw
                break
        shortest_path = net.shortest_path_to_gw(network_device=uav0,
                                                gateway=gateway)

        expected_links: list[NetworkLink] = []

        ap0: NetworkNode = list(filter(lambda ap: ap.name == &#34;ap_00&#34;,
                                  net.access_points))[0]
        expected_links.append(net[uav0][ap0][&#34;data&#34;])
        expected_links.append(net[ap0][uav0][&#34;data&#34;])
        switch_01: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_01&#34;,
                                  net.switches))[0]
        expected_links.append(net[ap0][switch_01][&#34;data&#34;])
        expected_links.append(net[switch_01][ap0][&#34;data&#34;])
        switch_04: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_04&#34;,
                                  net.switches))[0]
        expected_links.append(net[switch_01][switch_04][&#34;data&#34;])
        expected_links.append(net[switch_04][switch_01][&#34;data&#34;])
        expected_links.append(net[switch_04][gateway][&#34;data&#34;])
        expected_links.append(net[gateway][switch_04][&#34;data&#34;])
        zipped_links = zip(shortest_path, expected_links)
        for (l1, l2) in zipped_links:
            self.assertEqual(l1, l2)

    def test_assign_path_to_device(self):
        &#34;&#34;&#34;Test that, given a path and a NetworkDevice, the resources
        that the NetworkDevice request are allocated in all the
        NetworkLinks that make up the path.
        &#34;&#34;&#34;
        net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))

        uav0: NetworkDevice = None
        for uav in net.uavs:
            if (uav.name == &#34;uav_00&#34;):
                uav0 = uav
                break
        gateway: NetworkNode = None
        for gw in net.gateways:
            if (gw.name == &#34;gateway&#34;):
                gateway = gw
                break
        ap0: NetworkNode = list(filter(lambda ap: ap.name == &#34;ap_00&#34;,
                                  net.access_points))[0]
        switch_01: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_01&#34;,
                                  net.switches))[0]
        switch_04: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_04&#34;,
                                  net.switches))[0]
        path_of_uav0: list[NetworkLink] = []
        path_of_uav0.append(net[uav0][ap0][&#34;data&#34;])
        path_of_uav0.append(net[ap0][uav0][&#34;data&#34;])
        path_of_uav0.append(net[ap0][switch_01][&#34;data&#34;])
        path_of_uav0.append(net[switch_01][ap0][&#34;data&#34;])
        path_of_uav0.append(net[switch_01][switch_04][&#34;data&#34;])
        path_of_uav0.append(net[switch_04][switch_01][&#34;data&#34;])
        path_of_uav0.append(net[switch_04][gateway][&#34;data&#34;])
        path_of_uav0.append(net[gateway][switch_04][&#34;data&#34;])

        net.assign_path_to_device(device=uav0, path=path_of_uav0)
        for l in path_of_uav0:
            expected_available_throughput: float =\
                l.max_throughput - uav0.throughput_req
            self.assertEqual(l.available_throughput,
                             expected_available_throughput)
            self.assertTrue(uav0 in l.routed_flows)

    def test_get_path_device(self):
        &#34;&#34;&#34;Test that given a NetworkDevice, the path were its resources
        are allocated is returned. The order of NetworksLink is irrelevant.
        &#34;&#34;&#34;
        net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))
        uav0: NetworkDevice = None
        for uav in net.uavs:
            if (uav.name == &#34;uav_00&#34;):
                uav0 = uav
                break
        gateway: NetworkNode = None
        for gw in net.gateways:
            if (gw.name == &#34;gateway&#34;):
                gateway = gw
                break
        ap0: NetworkNode = list(filter(lambda ap: ap.name == &#34;ap_00&#34;,
                                  net.access_points))[0]
        switch_01: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_01&#34;,
                                  net.switches))[0]
        switch_04: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_04&#34;,
                                  net.switches))[0]
        expected_path_of_uav0: list[NetworkLink] = []
        expected_path_of_uav0.append(net[uav0][ap0][&#34;data&#34;])
        expected_path_of_uav0.append(net[ap0][uav0][&#34;data&#34;])
        expected_path_of_uav0.append(net[ap0][switch_01][&#34;data&#34;])
        expected_path_of_uav0.append(net[switch_01][ap0][&#34;data&#34;])
        expected_path_of_uav0.append(net[switch_01][switch_04][&#34;data&#34;])
        expected_path_of_uav0.append(net[switch_04][switch_01][&#34;data&#34;])
        expected_path_of_uav0.append(net[switch_04][gateway][&#34;data&#34;])
        expected_path_of_uav0.append(net[gateway][switch_04][&#34;data&#34;])
        net.assign_path_to_device(device=uav0, path=expected_path_of_uav0)
        actual_uav0_path  = net.get_path_device(uav0)
        self.assertEqual(len(expected_path_of_uav0), len(actual_uav0_path))
        for l in actual_uav0_path:
            self.assertTrue(l in expected_path_of_uav0)

    def test_free_path_device(self):
        &#34;&#34;&#34;Test that given a NetworkDevice, the allocation of its
        requested resources are removed from all the NetworkLinks of the
        Network.
        &#34;&#34;&#34;
        net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))
        uav0: NetworkDevice = None
        for uav in net.uavs:
            if (uav.name == &#34;uav_00&#34;):
                uav0 = uav
                break
        gateway: NetworkNode = None
        for gw in net.gateways:
            if (gw.name == &#34;gateway&#34;):
                gateway = gw
                break
        ap0: NetworkNode = list(filter(lambda ap: ap.name == &#34;ap_00&#34;,
                                  net.access_points))[0]
        switch_01: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_01&#34;,
                                  net.switches))[0]
        switch_04: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_04&#34;,
                                  net.switches))[0]
        path_of_uav0: list[NetworkLink] = []
        path_of_uav0.append(net[uav0][ap0][&#34;data&#34;])
        path_of_uav0.append(net[ap0][uav0][&#34;data&#34;])
        path_of_uav0.append(net[ap0][switch_01][&#34;data&#34;])
        path_of_uav0.append(net[switch_01][ap0][&#34;data&#34;])
        path_of_uav0.append(net[switch_01][switch_04][&#34;data&#34;])
        path_of_uav0.append(net[switch_04][switch_01][&#34;data&#34;])
        path_of_uav0.append(net[switch_04][gateway][&#34;data&#34;])
        path_of_uav0.append(net[gateway][switch_04][&#34;data&#34;])
        net.assign_path_to_device(device=uav0, path=path_of_uav0)

        net.free_path_device(uav0, path_of_uav0)

        for l in path_of_uav0:
            self.assertEqual(l.available_throughput, l.max_throughput)
            self.assertEqual(len(l.routed_flows), 0)

    def test_get_next_link(self):
        &#34;&#34;&#34;Test that given an ExtendedNetworkLink, the list of
        ExtendedNewtorkLinks that are returned lead to the gw of the
        network.
        &#34;&#34;&#34;
        net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))
        ap0: NetworkNode = list(filter(lambda ap: ap.name == &#34;ap_00&#34;,
                                  net.access_points))[0]
        switch_01: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_01&#34;,
                                  net.switches))[0]
        switch_02: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_02&#34;,
                                  net.switches))[0]
        switch_04: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_04&#34;,
                                  net.switches))[0]
        current_l: NetworkLink = net[ap0][switch_01]
        l_01_02: NetworkLink = net[switch_01][switch_02]
        l_01_04: NetworkLink = net[switch_01][switch_04]

        next_links: list[ExtendedNetworkLink] = net.get_next_link((ap0,
                                                                   switch_01,
                                                                   current_l))
        self.assertEqual(len(next_links), 2)
        self.assertTrue((switch_01, switch_02, l_01_02) in next_links)
        self.assertTrue((switch_01, switch_04, l_01_04) in next_links)

    def test_generate_uav_event(self):
        &#34;&#34;&#34;Test that when an event for a NetworkDevice of type
        NetworkDeviceType.UAV is generated, the NetworkLinks are updated
        consistenly and that the NetworkDevice is set to active.
        &#34;&#34;&#34;
        net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))
        seed: int = 0
        uav = net.generate_uav_event(seed=seed)
        self.assertTrue(uav.is_active)
        self.assertEqual(len(list(net.in_edges(uav))), 1)
        self.assertEqual(len(list(net.out_edges(uav))), 1)
        self.assertEqual(list(net.out_edges(uav))[0][1],
                         list(net.in_edges(uav))[0][0])


    def test_generate_cam_event(self):
        &#34;&#34;&#34;Test that when that events for NetworkDevices of type
        NetworkDeviceType.CAM only inactive cameras are taken into
        account and that the chosen is set to active.
        &#34;&#34;&#34;
        net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))
        seed: int = 0
        n_cams: int = len(net.cams)
        for i in range(n_cams):
            n_inactive_cameras: int = len(list(filter(
                lambda cam: not cam.is_active,
                net.cams)))
            self.assertEqual(n_inactive_cameras, n_cams - i)
            cam = net.generate_cam_event(seed=seed)
            self.assertTrue(cam.is_active)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="uav-mobility-app.tests.entities.test_Network.test_Network"><code class="flex name class">
<span>class <span class="ident">test_Network</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class test_Network(unittest.TestCase):


    def test_initialization(self):
        &#34;&#34;&#34;Checks that the initialization of a Network is consistent.
        &#34;&#34;&#34;
        input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
        input_data: dict = json.load(open(input_path))
        n_network_nodes: int = len(input_data[&#34;network_nodes&#34;])
        n_gws = len(list(filter(
            lambda network_node: network_node[&#34;node_type&#34;] == &#34;GW&#34;,
            input_data[&#34;network_nodes&#34;])))
        n_sws = len(list(filter(
            lambda network_node: network_node[&#34;node_type&#34;] == &#34;SW&#34;,
            input_data[&#34;network_nodes&#34;])))
        n_aps = len(list(filter(
            lambda network_node: network_node[&#34;node_type&#34;] == &#34;AP&#34;,
            input_data[&#34;network_nodes&#34;])))
        n_network_devices: int = len(input_data[&#34;network_devices&#34;])
        n_network_links: int = len(input_data[&#34;network_links&#34;])
        net = Network(input_path)
        self.assertEqual(len(net.nodes),
                         n_network_devices + n_network_nodes)
        self.assertEqual(len(net.gateways), n_gws)
        self.assertEqual(len(net.switches), n_sws)
        self.assertEqual(len(net.access_points), n_aps)
        self.assertEqual(len(net.edges),
                         n_network_links)

    def test_network_nodes(self):
        &#34;&#34;&#34;Test that the network nodes are consistent w.r.t. the input
        data.
        &#34;&#34;&#34;
        input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
        input_data = parse_json(input_path)
        expected_nodes: list[NetworkNode] = input_data[&#34;network_nodes&#34;]
        net = Network(input_path)
        zipped_nodes = zip(net.network_nodes, expected_nodes)
        for (n1, n2) in zipped_nodes:
            self.assertEqual(n1.id, n2.id)
            self.assertEqual(n1.name, n2.name)
            self.assertEqual(n1.node_type, n2.node_type)
            self.assertEqual(n1.position, n2.position)

    def test_gateways(self):
        &#34;&#34;&#34;Test that the NetworkNodes of type NetworkNodeType.GW are
        consistent w.r.t. the input data.
        &#34;&#34;&#34;
        input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
        input_data: list[NetworkNode] = parse_json(input_path)[&#34;network_nodes&#34;]
        expected_gateways: list[NetworkNode] = list(filter(
            lambda network_node: network_node.node_type == &#34;GW&#34;,
            input_data))
        net = Network(input_path)
        zipped_gateways = zip(net.gateways, expected_gateways)
        for (g1, g2) in zipped_gateways:
            self.assertEqual(g1.id, g2.id)
            self.assertEqual(g1.name, g2.name)
            self.assertEqual(g1.node_type, g2.node_type)
            self.assertEqual(g1.position, g2.position)

    def test_switches(self):
        &#34;&#34;&#34;Test that the NetworkNodes of type NetworkNodeType.SW are
        consistent w.r.t. the input data.
        &#34;&#34;&#34;
        input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
        input_data: list[NetworkNode] = parse_json(input_path)[&#34;network_nodes&#34;]
        expected_switches: list[NetworkNode] = list(filter(
            lambda network_node: network_node.node_type == &#34;SW&#34;,
            input_data))
        net = Network(input_path)
        zipped_switches = zip(net.switches, expected_switches)
        for (s1, s2) in zipped_switches:
            self.assertEqual(s1.id, s2.id)
            self.assertEqual(s1.name, s2.name)
            self.assertEqual(s1.node_type, s2.node_type)
            self.assertEqual(s1.position, s2.position)

    def test_access_points(self):
        &#34;&#34;&#34;Test that the NetworkNodes of type NetworkNodeType.AP are
        consistent w.r.t. the input data.
        &#34;&#34;&#34;
        input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
        input_data: list[NetworkNode] = parse_json(input_path)[&#34;network_nodes&#34;]
        expected_access_points: list[NetworkNode] = list(filter(
            lambda network_node: network_node.node_type == &#34;AP&#34;,
            input_data))
        net = Network(input_path)
        zipped_access_points = zip(net.switches, expected_access_points)
        for (a1, a2) in zipped_access_points:
            self.assertEqual(a1.id, a2.id)
            self.assertEqual(a1.name, a2.name)
            self.assertEqual(a1.node_type, a2.node_type)
            self.assertEqual(a1.position, a2.position)

    def test_network_devices(self):
        &#34;&#34;&#34;Test that the networkDevices are consistent w.r.t. the input
        data.
        &#34;&#34;&#34;
        input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
        input_data = parse_json(input_path)
        expected_devices : list[NetworkDevice] = input_data[&#34;network_devices&#34;]
        net = Network(input_path)
        zipped_devices = zip(net.network_devices, expected_devices)
        for (d1, d2) in zipped_devices:
            self.assertEqual(d1.id, d2.id)
            self.assertEqual(d1.name, d2.name)
            self.assertEqual(d1.device_type, d2.device_type)
            self.assertEqual(d1.throughput_req, d2.throughput_req)
            self.assertEqual(d1.delay_req, d2.delay_req)
            self.assertEqual(d1.position, d2.position)
            self.assertEqual(d1.is_active, d2.is_active)

    def test_uavs(self):
        &#34;&#34;&#34;Test that the NetworkDevices of type NetworkDeviceType.UAV
        are consistent w.r.t. the input data.
        &#34;&#34;&#34;
        input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
        input_data: list[NetworkDevice] = \
            parse_json(input_path)[&#34;network_devices&#34;]
        expected_uavs: list[NetworkDevice] = list(filter(
            lambda network_device: network_device.device_type == &#34;UAV&#34;,
            input_data))
        net = Network(input_path)
        zipped_uavs = zip(net.uavs, expected_uavs)
        for (u1, u2) in zipped_uavs:
            self.assertEqual(u1.id, u2.id)
            self.assertEqual(u1.name, u2.name)
            self.assertEqual(u1.device_type, u2.device_type)
            self.assertEqual(u1.throughput_req, u2.throughput_req)
            self.assertEqual(u1.delay_req, u2.delay_req)
            self.assertEqual(u1.position, u2.position)
            self.assertEqual(u1.is_active, u2.is_active)

    def test_cams(self):
        &#34;&#34;&#34;Test that the NetworkDevices of type NetworkDeviceType.CAM
        are consistent w.r.t. the input data.
        &#34;&#34;&#34;
        input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
        input_data: list[NetworkDevice] = \
            parse_json(input_path)[&#34;network_devices&#34;]
        expected_cams: list[NetworkDevice] = list(filter(
            lambda network_device: network_device.device_type == &#34;CAM&#34;,
            input_data))
        net = Network(input_path)
        zipped_cams = zip(net.cams, expected_cams)
        for (c1, c2) in zipped_cams:
            self.assertEqual(c1.id, c2.id)
            self.assertEqual(c1.name, c2.name)
            self.assertEqual(c1.device_type, c2.device_type)
            self.assertEqual(c1.throughput_req, c2.throughput_req)
            self.assertEqual(c1.delay_req, c2.delay_req)
            self.assertEqual(c1.position, c2.position)
            self.assertEqual(c1.is_active, c2.is_active)

    def test_network_links(self):
        &#34;&#34;&#34;Test that the NetworkLinks are consistent w.r.t. the input
        data.
        &#34;&#34;&#34;
        input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
        input_data = parse_json(input_path)
        expected_links = input_data[&#34;network_links&#34;]
        expected_links: list[NetworkLink] = [l[2] for l in expected_links]
        net = Network(input_path)
        zipped_links = zip(net.network_links, expected_links)
        for (l1, l2) in zipped_links:
            self.assertEqual(l1.id, l2.id)
            self.assertEqual(l1.name, l2.name)
            self.assertEqual(l1.max_throughput, l2.max_throughput)
            self.assertEqual(l1.available_throughput, l2.available_throughput)
            self.assertEqual(l1.routed_flows, l2.routed_flows)
            self.assertEqual(l1.delay, l2.delay)

    def test_shortest_path_to_gw(self):
        &#34;&#34;&#34;Test that the expected shortest paths from the testing
        scenario are returned in different situations.
        &#34;&#34;&#34;
        net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))

        uav0: NetworkDevice = None
        for uav in net.uavs:
            if (uav.name == &#34;uav_00&#34;):
                uav0 = uav
                break
        gateway: NetworkNode = None
        for gw in net.gateways:
            if (gw.name == &#34;gateway&#34;):
                gateway = gw
                break
        shortest_path = net.shortest_path_to_gw(network_device=uav0,
                                                gateway=gateway)

        expected_links: list[NetworkLink] = []

        ap0: NetworkNode = list(filter(lambda ap: ap.name == &#34;ap_00&#34;,
                                  net.access_points))[0]
        expected_links.append(net[uav0][ap0][&#34;data&#34;])
        expected_links.append(net[ap0][uav0][&#34;data&#34;])
        switch_01: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_01&#34;,
                                  net.switches))[0]
        expected_links.append(net[ap0][switch_01][&#34;data&#34;])
        expected_links.append(net[switch_01][ap0][&#34;data&#34;])
        switch_04: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_04&#34;,
                                  net.switches))[0]
        expected_links.append(net[switch_01][switch_04][&#34;data&#34;])
        expected_links.append(net[switch_04][switch_01][&#34;data&#34;])
        expected_links.append(net[switch_04][gateway][&#34;data&#34;])
        expected_links.append(net[gateway][switch_04][&#34;data&#34;])
        zipped_links = zip(shortest_path, expected_links)
        for (l1, l2) in zipped_links:
            self.assertEqual(l1, l2)

    def test_assign_path_to_device(self):
        &#34;&#34;&#34;Test that, given a path and a NetworkDevice, the resources
        that the NetworkDevice request are allocated in all the
        NetworkLinks that make up the path.
        &#34;&#34;&#34;
        net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))

        uav0: NetworkDevice = None
        for uav in net.uavs:
            if (uav.name == &#34;uav_00&#34;):
                uav0 = uav
                break
        gateway: NetworkNode = None
        for gw in net.gateways:
            if (gw.name == &#34;gateway&#34;):
                gateway = gw
                break
        ap0: NetworkNode = list(filter(lambda ap: ap.name == &#34;ap_00&#34;,
                                  net.access_points))[0]
        switch_01: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_01&#34;,
                                  net.switches))[0]
        switch_04: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_04&#34;,
                                  net.switches))[0]
        path_of_uav0: list[NetworkLink] = []
        path_of_uav0.append(net[uav0][ap0][&#34;data&#34;])
        path_of_uav0.append(net[ap0][uav0][&#34;data&#34;])
        path_of_uav0.append(net[ap0][switch_01][&#34;data&#34;])
        path_of_uav0.append(net[switch_01][ap0][&#34;data&#34;])
        path_of_uav0.append(net[switch_01][switch_04][&#34;data&#34;])
        path_of_uav0.append(net[switch_04][switch_01][&#34;data&#34;])
        path_of_uav0.append(net[switch_04][gateway][&#34;data&#34;])
        path_of_uav0.append(net[gateway][switch_04][&#34;data&#34;])

        net.assign_path_to_device(device=uav0, path=path_of_uav0)
        for l in path_of_uav0:
            expected_available_throughput: float =\
                l.max_throughput - uav0.throughput_req
            self.assertEqual(l.available_throughput,
                             expected_available_throughput)
            self.assertTrue(uav0 in l.routed_flows)

    def test_get_path_device(self):
        &#34;&#34;&#34;Test that given a NetworkDevice, the path were its resources
        are allocated is returned. The order of NetworksLink is irrelevant.
        &#34;&#34;&#34;
        net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))
        uav0: NetworkDevice = None
        for uav in net.uavs:
            if (uav.name == &#34;uav_00&#34;):
                uav0 = uav
                break
        gateway: NetworkNode = None
        for gw in net.gateways:
            if (gw.name == &#34;gateway&#34;):
                gateway = gw
                break
        ap0: NetworkNode = list(filter(lambda ap: ap.name == &#34;ap_00&#34;,
                                  net.access_points))[0]
        switch_01: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_01&#34;,
                                  net.switches))[0]
        switch_04: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_04&#34;,
                                  net.switches))[0]
        expected_path_of_uav0: list[NetworkLink] = []
        expected_path_of_uav0.append(net[uav0][ap0][&#34;data&#34;])
        expected_path_of_uav0.append(net[ap0][uav0][&#34;data&#34;])
        expected_path_of_uav0.append(net[ap0][switch_01][&#34;data&#34;])
        expected_path_of_uav0.append(net[switch_01][ap0][&#34;data&#34;])
        expected_path_of_uav0.append(net[switch_01][switch_04][&#34;data&#34;])
        expected_path_of_uav0.append(net[switch_04][switch_01][&#34;data&#34;])
        expected_path_of_uav0.append(net[switch_04][gateway][&#34;data&#34;])
        expected_path_of_uav0.append(net[gateway][switch_04][&#34;data&#34;])
        net.assign_path_to_device(device=uav0, path=expected_path_of_uav0)
        actual_uav0_path  = net.get_path_device(uav0)
        self.assertEqual(len(expected_path_of_uav0), len(actual_uav0_path))
        for l in actual_uav0_path:
            self.assertTrue(l in expected_path_of_uav0)

    def test_free_path_device(self):
        &#34;&#34;&#34;Test that given a NetworkDevice, the allocation of its
        requested resources are removed from all the NetworkLinks of the
        Network.
        &#34;&#34;&#34;
        net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))
        uav0: NetworkDevice = None
        for uav in net.uavs:
            if (uav.name == &#34;uav_00&#34;):
                uav0 = uav
                break
        gateway: NetworkNode = None
        for gw in net.gateways:
            if (gw.name == &#34;gateway&#34;):
                gateway = gw
                break
        ap0: NetworkNode = list(filter(lambda ap: ap.name == &#34;ap_00&#34;,
                                  net.access_points))[0]
        switch_01: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_01&#34;,
                                  net.switches))[0]
        switch_04: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_04&#34;,
                                  net.switches))[0]
        path_of_uav0: list[NetworkLink] = []
        path_of_uav0.append(net[uav0][ap0][&#34;data&#34;])
        path_of_uav0.append(net[ap0][uav0][&#34;data&#34;])
        path_of_uav0.append(net[ap0][switch_01][&#34;data&#34;])
        path_of_uav0.append(net[switch_01][ap0][&#34;data&#34;])
        path_of_uav0.append(net[switch_01][switch_04][&#34;data&#34;])
        path_of_uav0.append(net[switch_04][switch_01][&#34;data&#34;])
        path_of_uav0.append(net[switch_04][gateway][&#34;data&#34;])
        path_of_uav0.append(net[gateway][switch_04][&#34;data&#34;])
        net.assign_path_to_device(device=uav0, path=path_of_uav0)

        net.free_path_device(uav0, path_of_uav0)

        for l in path_of_uav0:
            self.assertEqual(l.available_throughput, l.max_throughput)
            self.assertEqual(len(l.routed_flows), 0)

    def test_get_next_link(self):
        &#34;&#34;&#34;Test that given an ExtendedNetworkLink, the list of
        ExtendedNewtorkLinks that are returned lead to the gw of the
        network.
        &#34;&#34;&#34;
        net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))
        ap0: NetworkNode = list(filter(lambda ap: ap.name == &#34;ap_00&#34;,
                                  net.access_points))[0]
        switch_01: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_01&#34;,
                                  net.switches))[0]
        switch_02: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_02&#34;,
                                  net.switches))[0]
        switch_04: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_04&#34;,
                                  net.switches))[0]
        current_l: NetworkLink = net[ap0][switch_01]
        l_01_02: NetworkLink = net[switch_01][switch_02]
        l_01_04: NetworkLink = net[switch_01][switch_04]

        next_links: list[ExtendedNetworkLink] = net.get_next_link((ap0,
                                                                   switch_01,
                                                                   current_l))
        self.assertEqual(len(next_links), 2)
        self.assertTrue((switch_01, switch_02, l_01_02) in next_links)
        self.assertTrue((switch_01, switch_04, l_01_04) in next_links)

    def test_generate_uav_event(self):
        &#34;&#34;&#34;Test that when an event for a NetworkDevice of type
        NetworkDeviceType.UAV is generated, the NetworkLinks are updated
        consistenly and that the NetworkDevice is set to active.
        &#34;&#34;&#34;
        net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))
        seed: int = 0
        uav = net.generate_uav_event(seed=seed)
        self.assertTrue(uav.is_active)
        self.assertEqual(len(list(net.in_edges(uav))), 1)
        self.assertEqual(len(list(net.out_edges(uav))), 1)
        self.assertEqual(list(net.out_edges(uav))[0][1],
                         list(net.in_edges(uav))[0][0])


    def test_generate_cam_event(self):
        &#34;&#34;&#34;Test that when that events for NetworkDevices of type
        NetworkDeviceType.CAM only inactive cameras are taken into
        account and that the chosen is set to active.
        &#34;&#34;&#34;
        net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))
        seed: int = 0
        n_cams: int = len(net.cams)
        for i in range(n_cams):
            n_inactive_cameras: int = len(list(filter(
                lambda cam: not cam.is_active,
                net.cams)))
            self.assertEqual(n_inactive_cameras, n_cams - i)
            cam = net.generate_cam_event(seed=seed)
            self.assertTrue(cam.is_active)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="uav-mobility-app.tests.entities.test_Network.test_Network.test_access_points"><code class="name flex">
<span>def <span class="ident">test_access_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that the NetworkNodes of type NetworkNodeType.AP are
consistent w.r.t. the input data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_access_points(self):
    &#34;&#34;&#34;Test that the NetworkNodes of type NetworkNodeType.AP are
    consistent w.r.t. the input data.
    &#34;&#34;&#34;
    input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
    input_data: list[NetworkNode] = parse_json(input_path)[&#34;network_nodes&#34;]
    expected_access_points: list[NetworkNode] = list(filter(
        lambda network_node: network_node.node_type == &#34;AP&#34;,
        input_data))
    net = Network(input_path)
    zipped_access_points = zip(net.switches, expected_access_points)
    for (a1, a2) in zipped_access_points:
        self.assertEqual(a1.id, a2.id)
        self.assertEqual(a1.name, a2.name)
        self.assertEqual(a1.node_type, a2.node_type)
        self.assertEqual(a1.position, a2.position)</code></pre>
</details>
</dd>
<dt id="uav-mobility-app.tests.entities.test_Network.test_Network.test_assign_path_to_device"><code class="name flex">
<span>def <span class="ident">test_assign_path_to_device</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that, given a path and a NetworkDevice, the resources
that the NetworkDevice request are allocated in all the
NetworkLinks that make up the path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_assign_path_to_device(self):
    &#34;&#34;&#34;Test that, given a path and a NetworkDevice, the resources
    that the NetworkDevice request are allocated in all the
    NetworkLinks that make up the path.
    &#34;&#34;&#34;
    net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))

    uav0: NetworkDevice = None
    for uav in net.uavs:
        if (uav.name == &#34;uav_00&#34;):
            uav0 = uav
            break
    gateway: NetworkNode = None
    for gw in net.gateways:
        if (gw.name == &#34;gateway&#34;):
            gateway = gw
            break
    ap0: NetworkNode = list(filter(lambda ap: ap.name == &#34;ap_00&#34;,
                              net.access_points))[0]
    switch_01: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_01&#34;,
                              net.switches))[0]
    switch_04: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_04&#34;,
                              net.switches))[0]
    path_of_uav0: list[NetworkLink] = []
    path_of_uav0.append(net[uav0][ap0][&#34;data&#34;])
    path_of_uav0.append(net[ap0][uav0][&#34;data&#34;])
    path_of_uav0.append(net[ap0][switch_01][&#34;data&#34;])
    path_of_uav0.append(net[switch_01][ap0][&#34;data&#34;])
    path_of_uav0.append(net[switch_01][switch_04][&#34;data&#34;])
    path_of_uav0.append(net[switch_04][switch_01][&#34;data&#34;])
    path_of_uav0.append(net[switch_04][gateway][&#34;data&#34;])
    path_of_uav0.append(net[gateway][switch_04][&#34;data&#34;])

    net.assign_path_to_device(device=uav0, path=path_of_uav0)
    for l in path_of_uav0:
        expected_available_throughput: float =\
            l.max_throughput - uav0.throughput_req
        self.assertEqual(l.available_throughput,
                         expected_available_throughput)
        self.assertTrue(uav0 in l.routed_flows)</code></pre>
</details>
</dd>
<dt id="uav-mobility-app.tests.entities.test_Network.test_Network.test_cams"><code class="name flex">
<span>def <span class="ident">test_cams</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that the NetworkDevices of type NetworkDeviceType.CAM
are consistent w.r.t. the input data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_cams(self):
    &#34;&#34;&#34;Test that the NetworkDevices of type NetworkDeviceType.CAM
    are consistent w.r.t. the input data.
    &#34;&#34;&#34;
    input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
    input_data: list[NetworkDevice] = \
        parse_json(input_path)[&#34;network_devices&#34;]
    expected_cams: list[NetworkDevice] = list(filter(
        lambda network_device: network_device.device_type == &#34;CAM&#34;,
        input_data))
    net = Network(input_path)
    zipped_cams = zip(net.cams, expected_cams)
    for (c1, c2) in zipped_cams:
        self.assertEqual(c1.id, c2.id)
        self.assertEqual(c1.name, c2.name)
        self.assertEqual(c1.device_type, c2.device_type)
        self.assertEqual(c1.throughput_req, c2.throughput_req)
        self.assertEqual(c1.delay_req, c2.delay_req)
        self.assertEqual(c1.position, c2.position)
        self.assertEqual(c1.is_active, c2.is_active)</code></pre>
</details>
</dd>
<dt id="uav-mobility-app.tests.entities.test_Network.test_Network.test_free_path_device"><code class="name flex">
<span>def <span class="ident">test_free_path_device</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that given a NetworkDevice, the allocation of its
requested resources are removed from all the NetworkLinks of the
Network.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_free_path_device(self):
    &#34;&#34;&#34;Test that given a NetworkDevice, the allocation of its
    requested resources are removed from all the NetworkLinks of the
    Network.
    &#34;&#34;&#34;
    net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))
    uav0: NetworkDevice = None
    for uav in net.uavs:
        if (uav.name == &#34;uav_00&#34;):
            uav0 = uav
            break
    gateway: NetworkNode = None
    for gw in net.gateways:
        if (gw.name == &#34;gateway&#34;):
            gateway = gw
            break
    ap0: NetworkNode = list(filter(lambda ap: ap.name == &#34;ap_00&#34;,
                              net.access_points))[0]
    switch_01: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_01&#34;,
                              net.switches))[0]
    switch_04: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_04&#34;,
                              net.switches))[0]
    path_of_uav0: list[NetworkLink] = []
    path_of_uav0.append(net[uav0][ap0][&#34;data&#34;])
    path_of_uav0.append(net[ap0][uav0][&#34;data&#34;])
    path_of_uav0.append(net[ap0][switch_01][&#34;data&#34;])
    path_of_uav0.append(net[switch_01][ap0][&#34;data&#34;])
    path_of_uav0.append(net[switch_01][switch_04][&#34;data&#34;])
    path_of_uav0.append(net[switch_04][switch_01][&#34;data&#34;])
    path_of_uav0.append(net[switch_04][gateway][&#34;data&#34;])
    path_of_uav0.append(net[gateway][switch_04][&#34;data&#34;])
    net.assign_path_to_device(device=uav0, path=path_of_uav0)

    net.free_path_device(uav0, path_of_uav0)

    for l in path_of_uav0:
        self.assertEqual(l.available_throughput, l.max_throughput)
        self.assertEqual(len(l.routed_flows), 0)</code></pre>
</details>
</dd>
<dt id="uav-mobility-app.tests.entities.test_Network.test_Network.test_gateways"><code class="name flex">
<span>def <span class="ident">test_gateways</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that the NetworkNodes of type NetworkNodeType.GW are
consistent w.r.t. the input data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_gateways(self):
    &#34;&#34;&#34;Test that the NetworkNodes of type NetworkNodeType.GW are
    consistent w.r.t. the input data.
    &#34;&#34;&#34;
    input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
    input_data: list[NetworkNode] = parse_json(input_path)[&#34;network_nodes&#34;]
    expected_gateways: list[NetworkNode] = list(filter(
        lambda network_node: network_node.node_type == &#34;GW&#34;,
        input_data))
    net = Network(input_path)
    zipped_gateways = zip(net.gateways, expected_gateways)
    for (g1, g2) in zipped_gateways:
        self.assertEqual(g1.id, g2.id)
        self.assertEqual(g1.name, g2.name)
        self.assertEqual(g1.node_type, g2.node_type)
        self.assertEqual(g1.position, g2.position)</code></pre>
</details>
</dd>
<dt id="uav-mobility-app.tests.entities.test_Network.test_Network.test_generate_cam_event"><code class="name flex">
<span>def <span class="ident">test_generate_cam_event</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that when that events for NetworkDevices of type
NetworkDeviceType.CAM only inactive cameras are taken into
account and that the chosen is set to active.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_generate_cam_event(self):
    &#34;&#34;&#34;Test that when that events for NetworkDevices of type
    NetworkDeviceType.CAM only inactive cameras are taken into
    account and that the chosen is set to active.
    &#34;&#34;&#34;
    net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))
    seed: int = 0
    n_cams: int = len(net.cams)
    for i in range(n_cams):
        n_inactive_cameras: int = len(list(filter(
            lambda cam: not cam.is_active,
            net.cams)))
        self.assertEqual(n_inactive_cameras, n_cams - i)
        cam = net.generate_cam_event(seed=seed)
        self.assertTrue(cam.is_active)</code></pre>
</details>
</dd>
<dt id="uav-mobility-app.tests.entities.test_Network.test_Network.test_generate_uav_event"><code class="name flex">
<span>def <span class="ident">test_generate_uav_event</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that when an event for a NetworkDevice of type
NetworkDeviceType.UAV is generated, the NetworkLinks are updated
consistenly and that the NetworkDevice is set to active.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_generate_uav_event(self):
    &#34;&#34;&#34;Test that when an event for a NetworkDevice of type
    NetworkDeviceType.UAV is generated, the NetworkLinks are updated
    consistenly and that the NetworkDevice is set to active.
    &#34;&#34;&#34;
    net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))
    seed: int = 0
    uav = net.generate_uav_event(seed=seed)
    self.assertTrue(uav.is_active)
    self.assertEqual(len(list(net.in_edges(uav))), 1)
    self.assertEqual(len(list(net.out_edges(uav))), 1)
    self.assertEqual(list(net.out_edges(uav))[0][1],
                     list(net.in_edges(uav))[0][0])</code></pre>
</details>
</dd>
<dt id="uav-mobility-app.tests.entities.test_Network.test_Network.test_get_next_link"><code class="name flex">
<span>def <span class="ident">test_get_next_link</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that given an ExtendedNetworkLink, the list of
ExtendedNewtorkLinks that are returned lead to the gw of the
network.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_next_link(self):
    &#34;&#34;&#34;Test that given an ExtendedNetworkLink, the list of
    ExtendedNewtorkLinks that are returned lead to the gw of the
    network.
    &#34;&#34;&#34;
    net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))
    ap0: NetworkNode = list(filter(lambda ap: ap.name == &#34;ap_00&#34;,
                              net.access_points))[0]
    switch_01: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_01&#34;,
                              net.switches))[0]
    switch_02: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_02&#34;,
                              net.switches))[0]
    switch_04: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_04&#34;,
                              net.switches))[0]
    current_l: NetworkLink = net[ap0][switch_01]
    l_01_02: NetworkLink = net[switch_01][switch_02]
    l_01_04: NetworkLink = net[switch_01][switch_04]

    next_links: list[ExtendedNetworkLink] = net.get_next_link((ap0,
                                                               switch_01,
                                                               current_l))
    self.assertEqual(len(next_links), 2)
    self.assertTrue((switch_01, switch_02, l_01_02) in next_links)
    self.assertTrue((switch_01, switch_04, l_01_04) in next_links)</code></pre>
</details>
</dd>
<dt id="uav-mobility-app.tests.entities.test_Network.test_Network.test_get_path_device"><code class="name flex">
<span>def <span class="ident">test_get_path_device</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that given a NetworkDevice, the path were its resources
are allocated is returned. The order of NetworksLink is irrelevant.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_path_device(self):
    &#34;&#34;&#34;Test that given a NetworkDevice, the path were its resources
    are allocated is returned. The order of NetworksLink is irrelevant.
    &#34;&#34;&#34;
    net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))
    uav0: NetworkDevice = None
    for uav in net.uavs:
        if (uav.name == &#34;uav_00&#34;):
            uav0 = uav
            break
    gateway: NetworkNode = None
    for gw in net.gateways:
        if (gw.name == &#34;gateway&#34;):
            gateway = gw
            break
    ap0: NetworkNode = list(filter(lambda ap: ap.name == &#34;ap_00&#34;,
                              net.access_points))[0]
    switch_01: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_01&#34;,
                              net.switches))[0]
    switch_04: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_04&#34;,
                              net.switches))[0]
    expected_path_of_uav0: list[NetworkLink] = []
    expected_path_of_uav0.append(net[uav0][ap0][&#34;data&#34;])
    expected_path_of_uav0.append(net[ap0][uav0][&#34;data&#34;])
    expected_path_of_uav0.append(net[ap0][switch_01][&#34;data&#34;])
    expected_path_of_uav0.append(net[switch_01][ap0][&#34;data&#34;])
    expected_path_of_uav0.append(net[switch_01][switch_04][&#34;data&#34;])
    expected_path_of_uav0.append(net[switch_04][switch_01][&#34;data&#34;])
    expected_path_of_uav0.append(net[switch_04][gateway][&#34;data&#34;])
    expected_path_of_uav0.append(net[gateway][switch_04][&#34;data&#34;])
    net.assign_path_to_device(device=uav0, path=expected_path_of_uav0)
    actual_uav0_path  = net.get_path_device(uav0)
    self.assertEqual(len(expected_path_of_uav0), len(actual_uav0_path))
    for l in actual_uav0_path:
        self.assertTrue(l in expected_path_of_uav0)</code></pre>
</details>
</dd>
<dt id="uav-mobility-app.tests.entities.test_Network.test_Network.test_initialization"><code class="name flex">
<span>def <span class="ident">test_initialization</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks that the initialization of a Network is consistent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_initialization(self):
    &#34;&#34;&#34;Checks that the initialization of a Network is consistent.
    &#34;&#34;&#34;
    input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
    input_data: dict = json.load(open(input_path))
    n_network_nodes: int = len(input_data[&#34;network_nodes&#34;])
    n_gws = len(list(filter(
        lambda network_node: network_node[&#34;node_type&#34;] == &#34;GW&#34;,
        input_data[&#34;network_nodes&#34;])))
    n_sws = len(list(filter(
        lambda network_node: network_node[&#34;node_type&#34;] == &#34;SW&#34;,
        input_data[&#34;network_nodes&#34;])))
    n_aps = len(list(filter(
        lambda network_node: network_node[&#34;node_type&#34;] == &#34;AP&#34;,
        input_data[&#34;network_nodes&#34;])))
    n_network_devices: int = len(input_data[&#34;network_devices&#34;])
    n_network_links: int = len(input_data[&#34;network_links&#34;])
    net = Network(input_path)
    self.assertEqual(len(net.nodes),
                     n_network_devices + n_network_nodes)
    self.assertEqual(len(net.gateways), n_gws)
    self.assertEqual(len(net.switches), n_sws)
    self.assertEqual(len(net.access_points), n_aps)
    self.assertEqual(len(net.edges),
                     n_network_links)</code></pre>
</details>
</dd>
<dt id="uav-mobility-app.tests.entities.test_Network.test_Network.test_network_devices"><code class="name flex">
<span>def <span class="ident">test_network_devices</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that the networkDevices are consistent w.r.t. the input
data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_network_devices(self):
    &#34;&#34;&#34;Test that the networkDevices are consistent w.r.t. the input
    data.
    &#34;&#34;&#34;
    input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
    input_data = parse_json(input_path)
    expected_devices : list[NetworkDevice] = input_data[&#34;network_devices&#34;]
    net = Network(input_path)
    zipped_devices = zip(net.network_devices, expected_devices)
    for (d1, d2) in zipped_devices:
        self.assertEqual(d1.id, d2.id)
        self.assertEqual(d1.name, d2.name)
        self.assertEqual(d1.device_type, d2.device_type)
        self.assertEqual(d1.throughput_req, d2.throughput_req)
        self.assertEqual(d1.delay_req, d2.delay_req)
        self.assertEqual(d1.position, d2.position)
        self.assertEqual(d1.is_active, d2.is_active)</code></pre>
</details>
</dd>
<dt id="uav-mobility-app.tests.entities.test_Network.test_Network.test_network_links"><code class="name flex">
<span>def <span class="ident">test_network_links</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that the NetworkLinks are consistent w.r.t. the input
data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_network_links(self):
    &#34;&#34;&#34;Test that the NetworkLinks are consistent w.r.t. the input
    data.
    &#34;&#34;&#34;
    input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
    input_data = parse_json(input_path)
    expected_links = input_data[&#34;network_links&#34;]
    expected_links: list[NetworkLink] = [l[2] for l in expected_links]
    net = Network(input_path)
    zipped_links = zip(net.network_links, expected_links)
    for (l1, l2) in zipped_links:
        self.assertEqual(l1.id, l2.id)
        self.assertEqual(l1.name, l2.name)
        self.assertEqual(l1.max_throughput, l2.max_throughput)
        self.assertEqual(l1.available_throughput, l2.available_throughput)
        self.assertEqual(l1.routed_flows, l2.routed_flows)
        self.assertEqual(l1.delay, l2.delay)</code></pre>
</details>
</dd>
<dt id="uav-mobility-app.tests.entities.test_Network.test_Network.test_network_nodes"><code class="name flex">
<span>def <span class="ident">test_network_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that the network nodes are consistent w.r.t. the input
data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_network_nodes(self):
    &#34;&#34;&#34;Test that the network nodes are consistent w.r.t. the input
    data.
    &#34;&#34;&#34;
    input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
    input_data = parse_json(input_path)
    expected_nodes: list[NetworkNode] = input_data[&#34;network_nodes&#34;]
    net = Network(input_path)
    zipped_nodes = zip(net.network_nodes, expected_nodes)
    for (n1, n2) in zipped_nodes:
        self.assertEqual(n1.id, n2.id)
        self.assertEqual(n1.name, n2.name)
        self.assertEqual(n1.node_type, n2.node_type)
        self.assertEqual(n1.position, n2.position)</code></pre>
</details>
</dd>
<dt id="uav-mobility-app.tests.entities.test_Network.test_Network.test_shortest_path_to_gw"><code class="name flex">
<span>def <span class="ident">test_shortest_path_to_gw</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that the expected shortest paths from the testing
scenario are returned in different situations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_shortest_path_to_gw(self):
    &#34;&#34;&#34;Test that the expected shortest paths from the testing
    scenario are returned in different situations.
    &#34;&#34;&#34;
    net: Network = Network(Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;))

    uav0: NetworkDevice = None
    for uav in net.uavs:
        if (uav.name == &#34;uav_00&#34;):
            uav0 = uav
            break
    gateway: NetworkNode = None
    for gw in net.gateways:
        if (gw.name == &#34;gateway&#34;):
            gateway = gw
            break
    shortest_path = net.shortest_path_to_gw(network_device=uav0,
                                            gateway=gateway)

    expected_links: list[NetworkLink] = []

    ap0: NetworkNode = list(filter(lambda ap: ap.name == &#34;ap_00&#34;,
                              net.access_points))[0]
    expected_links.append(net[uav0][ap0][&#34;data&#34;])
    expected_links.append(net[ap0][uav0][&#34;data&#34;])
    switch_01: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_01&#34;,
                              net.switches))[0]
    expected_links.append(net[ap0][switch_01][&#34;data&#34;])
    expected_links.append(net[switch_01][ap0][&#34;data&#34;])
    switch_04: NetworkNode = list(filter(lambda ap: ap.name == &#34;switch_04&#34;,
                              net.switches))[0]
    expected_links.append(net[switch_01][switch_04][&#34;data&#34;])
    expected_links.append(net[switch_04][switch_01][&#34;data&#34;])
    expected_links.append(net[switch_04][gateway][&#34;data&#34;])
    expected_links.append(net[gateway][switch_04][&#34;data&#34;])
    zipped_links = zip(shortest_path, expected_links)
    for (l1, l2) in zipped_links:
        self.assertEqual(l1, l2)</code></pre>
</details>
</dd>
<dt id="uav-mobility-app.tests.entities.test_Network.test_Network.test_switches"><code class="name flex">
<span>def <span class="ident">test_switches</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that the NetworkNodes of type NetworkNodeType.SW are
consistent w.r.t. the input data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_switches(self):
    &#34;&#34;&#34;Test that the NetworkNodes of type NetworkNodeType.SW are
    consistent w.r.t. the input data.
    &#34;&#34;&#34;
    input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
    input_data: list[NetworkNode] = parse_json(input_path)[&#34;network_nodes&#34;]
    expected_switches: list[NetworkNode] = list(filter(
        lambda network_node: network_node.node_type == &#34;SW&#34;,
        input_data))
    net = Network(input_path)
    zipped_switches = zip(net.switches, expected_switches)
    for (s1, s2) in zipped_switches:
        self.assertEqual(s1.id, s2.id)
        self.assertEqual(s1.name, s2.name)
        self.assertEqual(s1.node_type, s2.node_type)
        self.assertEqual(s1.position, s2.position)</code></pre>
</details>
</dd>
<dt id="uav-mobility-app.tests.entities.test_Network.test_Network.test_uavs"><code class="name flex">
<span>def <span class="ident">test_uavs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that the NetworkDevices of type NetworkDeviceType.UAV
are consistent w.r.t. the input data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_uavs(self):
    &#34;&#34;&#34;Test that the NetworkDevices of type NetworkDeviceType.UAV
    are consistent w.r.t. the input data.
    &#34;&#34;&#34;
    input_path: Path = Path.cwd().joinpath(&#34;input&#34;, &#34;network_00.json&#34;)
    input_data: list[NetworkDevice] = \
        parse_json(input_path)[&#34;network_devices&#34;]
    expected_uavs: list[NetworkDevice] = list(filter(
        lambda network_device: network_device.device_type == &#34;UAV&#34;,
        input_data))
    net = Network(input_path)
    zipped_uavs = zip(net.uavs, expected_uavs)
    for (u1, u2) in zipped_uavs:
        self.assertEqual(u1.id, u2.id)
        self.assertEqual(u1.name, u2.name)
        self.assertEqual(u1.device_type, u2.device_type)
        self.assertEqual(u1.throughput_req, u2.throughput_req)
        self.assertEqual(u1.delay_req, u2.delay_req)
        self.assertEqual(u1.position, u2.position)
        self.assertEqual(u1.is_active, u2.is_active)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="uav-mobility-app.tests.entities" href="index.html">uav-mobility-app.tests.entities</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="uav-mobility-app.tests.entities.test_Network.test_Network" href="#uav-mobility-app.tests.entities.test_Network.test_Network">test_Network</a></code></h4>
<ul class="">
<li><code><a title="uav-mobility-app.tests.entities.test_Network.test_Network.test_access_points" href="#uav-mobility-app.tests.entities.test_Network.test_Network.test_access_points">test_access_points</a></code></li>
<li><code><a title="uav-mobility-app.tests.entities.test_Network.test_Network.test_assign_path_to_device" href="#uav-mobility-app.tests.entities.test_Network.test_Network.test_assign_path_to_device">test_assign_path_to_device</a></code></li>
<li><code><a title="uav-mobility-app.tests.entities.test_Network.test_Network.test_cams" href="#uav-mobility-app.tests.entities.test_Network.test_Network.test_cams">test_cams</a></code></li>
<li><code><a title="uav-mobility-app.tests.entities.test_Network.test_Network.test_free_path_device" href="#uav-mobility-app.tests.entities.test_Network.test_Network.test_free_path_device">test_free_path_device</a></code></li>
<li><code><a title="uav-mobility-app.tests.entities.test_Network.test_Network.test_gateways" href="#uav-mobility-app.tests.entities.test_Network.test_Network.test_gateways">test_gateways</a></code></li>
<li><code><a title="uav-mobility-app.tests.entities.test_Network.test_Network.test_generate_cam_event" href="#uav-mobility-app.tests.entities.test_Network.test_Network.test_generate_cam_event">test_generate_cam_event</a></code></li>
<li><code><a title="uav-mobility-app.tests.entities.test_Network.test_Network.test_generate_uav_event" href="#uav-mobility-app.tests.entities.test_Network.test_Network.test_generate_uav_event">test_generate_uav_event</a></code></li>
<li><code><a title="uav-mobility-app.tests.entities.test_Network.test_Network.test_get_next_link" href="#uav-mobility-app.tests.entities.test_Network.test_Network.test_get_next_link">test_get_next_link</a></code></li>
<li><code><a title="uav-mobility-app.tests.entities.test_Network.test_Network.test_get_path_device" href="#uav-mobility-app.tests.entities.test_Network.test_Network.test_get_path_device">test_get_path_device</a></code></li>
<li><code><a title="uav-mobility-app.tests.entities.test_Network.test_Network.test_initialization" href="#uav-mobility-app.tests.entities.test_Network.test_Network.test_initialization">test_initialization</a></code></li>
<li><code><a title="uav-mobility-app.tests.entities.test_Network.test_Network.test_network_devices" href="#uav-mobility-app.tests.entities.test_Network.test_Network.test_network_devices">test_network_devices</a></code></li>
<li><code><a title="uav-mobility-app.tests.entities.test_Network.test_Network.test_network_links" href="#uav-mobility-app.tests.entities.test_Network.test_Network.test_network_links">test_network_links</a></code></li>
<li><code><a title="uav-mobility-app.tests.entities.test_Network.test_Network.test_network_nodes" href="#uav-mobility-app.tests.entities.test_Network.test_Network.test_network_nodes">test_network_nodes</a></code></li>
<li><code><a title="uav-mobility-app.tests.entities.test_Network.test_Network.test_shortest_path_to_gw" href="#uav-mobility-app.tests.entities.test_Network.test_Network.test_shortest_path_to_gw">test_shortest_path_to_gw</a></code></li>
<li><code><a title="uav-mobility-app.tests.entities.test_Network.test_Network.test_switches" href="#uav-mobility-app.tests.entities.test_Network.test_Network.test_switches">test_switches</a></code></li>
<li><code><a title="uav-mobility-app.tests.entities.test_Network.test_Network.test_uavs" href="#uav-mobility-app.tests.entities.test_Network.test_Network.test_uavs">test_uavs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>